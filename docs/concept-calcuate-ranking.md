 1️⃣ Rank와 Percentile 계산 방식

  답변: 네, 맞습니다. 매 호출마다 DB를 재검색해서 실시간으로 계산됩니다.

  구체적으로 보면:

  RankingService:218-254의 _calculate_rank() 메서드:

- API 호출 시마다 90일 기간 내의 모든 사용자들의 점수를 조회 (cohort_query)
- 그 중에서 현재 사용자의 점수보다 높은 점수를 받은 사용자 수를 계산
- 그 숫자 + 1 = 최종 rank

  이점:

- 동적으로 변함 (다른 사용자가 테스트를 완료하면 순위가 내려감)
- 실시간 순위 보장

  2️⃣ score=86.66은 어디서 계산되나?

  답변: test_results 테이블을 기반으로 계산됩니다.

  정확한 계산 과정 (RankingService:140-184의 _calculate_composite_score()):

  1. test_results 테이블에서 사용자의 모든 테스트 결과 조회
     └─ 각 TestResult.score (기본 점수)

  2. 각 결과에 대해:
     a) 정확도 보너스 계산
        └─ correct_rate = correct_count / total_count
        └─ bonus = correct_rate × 5% (최대 5점)

     b) 조정된 점수 = base_score + bonus (최대 100)

     c) 라운드별 가중치 적용
        └─ Round 2: 가중치 2.0 (더 중요함)
        └─ Round 1: 가중치 1.0

  3. 최종 점수 = Σ(조정된_점수 × 가중치) / Σ가중치

  예시 (당신의 86.66 점수):

- Round 1: 85점 × 1.0 = 85
- Round 2: 88점 × 2.0 = 176
- 합계: (85 + 176) / (1 + 2) = 261 / 3 = 87.0점 (대략)

  정확한 값은 각 라운드의 correct_count와 total_count에 따라 결정됩니다.

  ---
  핵심 테이블:

  | 테이블             | 역할                                                |
  |-----------------|---------------------------------------------------|
  | test_results    | 라운드별 최종 점수 저장 (score, correct_count, total_count) |
  | attempt_answers | 개별 문제별 답변 저장 (user_answer, is_correct, score)     |
  | test_sessions   | 테스트 세션 정보 (status 필터링)                            |

---
Example)
  86.66 점수 계산 흐름

  정확한 과정:

  1. test_results 테이블에서 사용자의 모든 라운드 조회
     ├─ Round 1: score=85, correct_count=17, total_count=20
     └─ Round 2: score=88, correct_count=18, total_count=20

  2. _calculate_composite_score()에서:
     ├─ Round 1 정확도: 17/20 = 0.85 → 보너스 4.25점
     │  └─ 조정 점수 = 85 + 4.25 = 89.25 (가중치: 1.0)
     ├─ Round 2 정확도: 18/20 = 0.90 → 보너스 4.5점
     │  └─ 조정 점수 = 88 + 4.5 = 92.5 (가중치: 2.0)
     └─ 최종 = (89.25 × 1 + 92.5 × 2) / 3 = 274.25 / 3 = 91.41...

  3. Rank 계산:
     ├─ 90일 내 전체 사용자 조회 (cohort_query)
     └─ 현재 사용자보다 높은 점수 사용자 수 → Rank 결정

  4. Percentile 계산:
     ├─ percentile = (total_cohort - rank + 1) / total_cohort × 100
     └─ 표시: "상위 0.0%" (rank #1이므로)

  ---
  핵심:

- test_results의 score 필드가 라운드별 기본 점수
- attempt_answers는 참고하지 않음 (점수 계산에는 TestResult만 사용)
- 보너스와 가중치를 적용해 최종 86.66 도출

---

● 문서에는 아직 자세한 설명이 없네요. 90일 제약의 장점을 설명드리겠습니다.

  🎯 왜 90일 제약이 좋은가?

  1️⃣ 공정한 비교 (Fair Comparison)

  전체 사용자와 비교하면:
  ❌ 나쁜 예: 전체 사용자 대비

- 2023년에 입사한 직원 vs 2025년에 입사한 직원 비교
- 경력 3년 vs 경력 10년 비교 → 의미 없는 순위

  ✅ 좋은 예: 90일 내 활동한 사용자 대비

- 최근 3개월 동안 테스트한 사람들끼리만 비교
- 같은 시간대에 같은 교육 환경을 받은 동기들과 비교

  2️⃣ 현재 수준의 정확한 반영 (Current Capability)

  예시: 당신이 2년 전에 점수 50점 받았다면?

  ❌ 전체 사용자 포함:

- 지난 2년 동안 성장했는데도 순위에 영향
- "과거의 나"와의 비교 → 의미 없음

  ✅ 90일 제약:

- 최근 3개월 내의 테스트만 고려
- 현재 당신의 실력을 정확히 반영

  3️⃣ 조직의 현재 역량 파악 (Organizational Insight)

  회사 입장에서:

- 90일 전: "예전 직원들의 점수"
- 90일 이내: "현재 활동 중인 직원들의 실력"

  → 현재 팀의 평균 역량 수준을 알 수 있음
  → 최근 교육 효과 측정 가능

  4️⃣ 동기부여 (Motivation)

  ❌ 전체 사용자:

- 10년 전 정년퇴직자도 포함
- "아, 저 사람은 내가 따라잡을 수 없겠네..."
- 동기 저하

  ✅ 90일 제약:

- "이 3개월 내에 나처럼 열심히 공부한 사람들 중에서..."
- "내 동기들이랑 공정하게 비교된다!"
- 동기 향상

  5️⃣ 성능 (Performance)

  ❌ 전체 사용자 (대규모 조직):

- 100,000명이 있다면?
- 매 API 호출 시마다 100,000명의 점수 계산
- 데이터베이스 부하 ↑↑↑

  ✅ 90일 제약:

- 실제로는 활동 중인 사람만 (예: 5,000명)
- 쿼리 성능 ↑
- DB 인덱스도 더 효율적

  ---
  📊 구체적인 예시

  당신의 회사가 1,000명의 직원이 있다면:

  | 방식     | 비교 대상         | 문제점                       |
  |--------|---------------|---------------------------|
  | 전체 사용자 | 1,000명 모두     | 5년 전 퇴사자, 휴직자 포함 → 불공정    |
  | 90일 제약 | 최근 활동 중인 200명 | 현재 팀의 실력만 비교 → 공정하고 의미 있음 |

  ---
  🎓 최종 정리

  90일 제약의 핵심 이유:

  1. 공정성 - 같은 조건의 사람들끼리 비교
  2. 현재성 - 지금의 실력 반영 (과거 기록은 제외)
  3. 동기 - "내 또래 동료들과 비교된다"는 느낌
  4. 성능 - 대규모 조직에서 DB 부하 감소
  5. 의미 - 조직 현재 상태의 정확한 측정

  당신의 초기 생각(전체 사용자)도 논리적이지만, 시간의 흐름과 직원 변동을 고려하면 90일이 더 현실적입니다!
